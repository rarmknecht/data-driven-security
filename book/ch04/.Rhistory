# Setting up for Chapter 3
# set the working directory
location <- "/Github/data-driven-security/"
setwd(paste("~",location,"book/ch03",sep=""))
# make sure that the packages needed are installed
# install if neccesary
pkg <- c("ggplot2","scales","maptools","sp","maps","grid","car")
new.pkg <- pkg[!(pkg %in% installed.packages())]
if(length(new.pkg)) { install.packages(new.pkg)}
avURL <- "http://datadrivensecurity.info/book/ch03/data/reputation.data"
avRep <- "data/reputation.data"
if (file.access(avRep)) {download.file(avURL,avRep)}
if (file.access(avRep)) {download.file(avURL,avRep)}
av <- read.csv(avRep,sep="#",header=FALSE)
colnames(av) <- c("IP","Reliability","Risk","Type",
"Country","Locale","Coords","x")
str(av)
head(av)
summary(av$Reliability)
summary(av$Risk)
table(av$Reliability)
plot(table(av$Reliability))
table(av$Reliability)
plot(table(av$Reliability)) # Visualize it
table(av$Risk)
plot(table(av$Risk)) # Visualize it
summary(av$Type, maxsum=10)
summary(av$Country, maxsum=40)
library(ggplot2)
country.top20 <- names(summary(av$Country))[1:20]
gg <- ggplot(data=subset(av,Country %in% country.top20),
aes(x=reorder(Country,Country,length)))
gg <- gg + geom_bar(fill="#000099")
gg <- gg + labs(title="Country Counts", x="Country", y="Count")
gg <- gg + coord_flip()
gg <- gg + theme(panel.grid=element_blank(),
panel.background=element_blank())
print(gg)
gg <- ggplot(data=av, aes(x=Risk))
gg <- geom_bar(fill="#009900")
gg <- gg + scale_x_discrete(limits=seq(max(av$Risk)))
av$Risk
max(av$Risk)
scale_x_discrete(limits=seq(max(av$Risk)))
gg <- gg + scale_x_discrete(limits=seq(max(av$Risk)))
gg <- gg + labs(title="Risk Counts",x="Risk Score", y="Count")
gg <- ggplot(data=av, aes(x=Risk))
gg <- gg + geom_bar(fill="#009900")
# force X to scale to be just the limits of the data and discrete vs. continuous
gg <- gg + scale_x_discrete(limits=seq(max(av$Risk)))
gg <- gg + labs(title="Risk Counts",x="Risk Score", y="Count")
gg <- gg + theme(panel.grid=element_blank(),
panel.background=element_blank())
print(gg)
gg <- ggplot(data=av, aes(x=Reliability))
gg <- gg + geom_bar(fill="#009900")
# force X to scale to be just the limits of the data and discrete vs. continuous
gg <- gg + scale_x_discrete(limits=seq(max(av$Reliability)))
gg <- gg + labs(title="Reliability Counts",x="Reliability Score", y="Count")
gg <- gg + theme(panel.grid=element_blank(),
panel.background=element_blank())
print(gg)
gg <- ggplot(data=av, aes(x=Risk))
gg <- gg + geom_bar(fill="#990000")
# force X to scale to be just the limits of the data and discrete vs. continuous
gg <- gg + scale_x_discrete(limits=seq(max(av$Risk)))
gg <- gg + labs(title="Risk Counts",x="Risk Score", y="Count")
gg <- gg + theme(panel.grid=element_blank(),
panel.background=element_blank())
print(gg)
table(av$Country)
sum(table(av$Country))
av$Country %in% top10
av$Country %in% c("US","CN")
rr.tab <- xtabs(~Risk+Reliability, data=av)
ftable(rr.tab)
library(lattice)
rr.df = data.frame(table(av$Risk, av$Reliability))
colnames(rr.df) <- c("Risk", "Reliability", "Freq")
levelplot(Freq~Risk*Reliability, data=rr.df, main="Risk ~ Reliability", ylab="Reliability",
xlab="Risk", shrink=c(0.5,1),col.regions=colorRampPalette(c("#009900","#990000"))(20))
levelplot(Freq~Risk*Reliability, data=rr.df, main="Risk ~ Reliability", ylab="Reliability",
xlab="Risk", shrink=c(0.5,1),col.regions=colorRampPalette(c("#00ee00","#990000"))(20))
levelplot(Freq~Risk*Reliability, data=rr.df, main="Risk ~ Reliability", ylab="Reliability",
xlab="Risk", shrink=c(0.5,1),col.regions=colorRampPalette(c("#009900","#990000"))(20))
levelplot(Freq~Risk*Reliability, data=rr.df, main="Risk ~ Reliability", ylab="Reliability",
xlab="Risk", shrink=c(0.5,1),col.regions=colorRampPalette(c("#ccddcc","#990000"))(20))
levelplot(Freq~Risk*Reliability, data=rr.df, main="Risk ~ Reliability", ylab="Reliability",
xlab="Risk", shrink=c(0.5,1),col.regions=colorRampPalette(c("#dcefdc","#990000"))(20))
set.seed(1492)
rel=sample(1:7,260000,replace=T)
rsk=sample(1:10,260000,replace=T)
tmp.df = data.frame(table(factor(rsk),factor(rel)))
colnames(tmp.df) <- c("Risk","Reliability","Freq")
levelplot(Freq~Risk*Reliability, data=tmp.df, main="Risk ~ Reliability", ylab="Reliability",
xlab="Risk", shrink=c(0.5,1),col.regions=colorRampPalette(c("#dcefdc","#990000"))(20))
av$simpleType <- as.character(av$Type)
av$simpleType[grep(';', av$simpleType)] <- "Multiples"
describe(av)
summary(av)
av$simpleType <- factor(av$simpleType)
rrt.df = data.frame(table(av$Risk, av$Reliability, av$simpleType))
colnames(rrt.df) <- c("Risk","Reliability","simpleType","Freq")
levelplot(Freq ~ Reliability*Risk|simpleType, data=rrt.df,
main="Risk ~ Reliability | Type", ylab="Risk", xlab="Reliability", shrink=c(0.5,1),
col.regions=colorRampPalette(c("#efefef","#990000"))(20))
rrt.df <- subset(rtt.df, simpleType != "Scanning Host")
rrt.df <- subset(rrt.df, simpleType != "Scanning Host")
levelplot(Freq ~ Reliability*Risk|simpleType, data=rrt.df,
main="Risk ~ Reliability | Type", ylab="Risk", xlab="Reliability", shrink=c(0.5,1),
col.regions=colorRampPalette(c("#efefef","#990000"))(20))
rrt.df <- subset(rrt.df,
!(simpleType %in% c("Malware distribution","Malware Domain")))
sprintf("Count: %d; Percent: %2.1f%%",
sum(rrt.df$Freq), 100*sum(rrt.df$Freq)/nrow(av))
levelplot(Freq ~ Reliability*Risk|simpleType, data=rrt.df,
main="Risk ~ Reliability | Type", ylab="Risk", xlab="Reliability", shrink=c(0.5,1),
col.regions=colorRampPalette(c("#efefef","#990000"))(20))
location <- "/Github/data-driven-security/"
setwd(paste("~",location,"book/ch04",sep=""))
pkg <- c("bitops","ggplot2","maps","maptools",
"sp","grid","car")
new.pkg <- pkg[!(pkg %in% installed.packages())]
if(length(new.pkg)) {install.packages(new.pkg)}
ip2long <- function(ip) {
# convert string to character vector
ips <- unlist(strsplit(ip,'.',fixed=TRUE))
# setup a function to bitshift and OR the octets
octet <- function(x,y) { bitOr(bitShiftL(x,8),y)}
# reduce applies the function cumulatively from left to right
reduce(octet, as.integer(ips))
}
long2ip <- function(longip) {
# setup reverse bit manipulation
octet <- function(nbits) { bitAnd(bitShiftR(longip, nbits),0xFF) }
# Map applies a function to each element of the argument
# paste converts arguments to character and concatenates them
paste(Map(octet,c(24,16,8,0)), sep="", collapse=".")
}
long2ip(ip2long("10.10.57.14"))
library(bitops)
long2ip(ip2long("10.10.57.14"))
long2ip(ip2long("10.10.57.14"))
ip2long <- function(ip) {
# convert string to character vector
ips <- unlist(strsplit(ip,'.',fixed=TRUE))
# setup a function to bitshift and OR the octets
octet <- function(x,y) { bitOr(bitShiftL(x,8),y) }
# reduce applies the function cumulatively from left to right
Reduce(octet, as.integer(ips))
}
long2ip(ip2long("10.10.57.14"))
ip.is.in.cidr <- function(ip,cidr) {
long.ip <- ip2long(ip)
cidr.parts <- unlist(strsplit(cidr,"/"))
cidr.range <- ip2long(cidr.parts[1])
cidr.mask <- bitshiftL(bitFlip(0),(32-as.integer(cidr.parts[2])))
return(bitAnd(long.ip, cidr.mask) == bitAnd(cidr.range,cidr.mask))
}
ip.is.in.cidr("10.0.1.15","10.0.1.3/24")
library(bitops)
ip.is.in.cidr <- function(ip,cidr) {
long.ip <- ip2long(ip)
cidr.parts <- unlist(strsplit(cidr,"/"))
cidr.range <- ip2long(cidr.parts[1])
cidr.mask <- bitShiftL(bitFlip(0),(32-as.integer(cidr.parts[2])))
return(bitAnd(long.ip, cidr.mask) == bitAnd(cidr.range,cidr.mask))
}
ip.is.in.cidr("10.0.1.15","10.0.1.3/24")
ip.is.in.cidr("10.0.1.15","10.0.2.0/24")
avRep <- "data/reputation.data"
av.df <- read.csv(avRep, sep="#", header=FALSE)
colnames(av.df) <- c("IP","Reliability","Risk","Type",
"Country", "Locale", "Coords", "x")
av.coords.vec <- unlist(strsplit(as.character(av.df$Coords),","))
av.coords.mat <- matrix(av.coords.vec, ncol=2, byrow=TRUE)
av.coords.df <- as.data.frame(av.coords.mat)
test <- data.frame(av.coords.mat)
View(test)
colnames(av.coords.df) <- c("lat","long")
colnames(av.coords.df) <- c("lat","long")
av.coords.df$long <- as.double(as.character(av.coords.df$long))
av.coords.df$lat <- as.double(as.character(av.coords.df$lat))
library(ggplot2)
library(maps)
library(RColorBrewer)
library(scales)
# extract a color palette from the RColorBrewer pkg
set2 <- brewer.pal(8,"Set2")
world <- map_data("world")
world <- subset(world, region != "Antartica")
gg <- ggplot()
gg <- gg + geom_polygon(data=world, aes(long, lat, group=group), fill="white")
gg <- gg + geom_point(data=av.coords.df, aes(x=long, y=lat),
color=set2[2], size=1, alpha=0.1)
gg <- gg + labs(x="", y="")
gg <- gg + theme(panel.background=element_rect(fill=alpha(set2[3],0.2),
colour="white"))
gg
world <- map_data("world")
world <- subset(world, region != "Antarctica")
gg <- ggplot()
gg <- gg + geom_polygon(data=world, aes(long, lat, group=group), fill="white")
gg <- gg + geom_point(data=av.coords.df, aes(x=long, y=lat),
color=set2[2], size=1, alpha=0.1)
gg <- gg + labs(x="", y="")
gg <- gg + theme(panel.background=element_rect(fill=alpha(set2[3],0.2),
colour="white"))
gg
iana.data <- "data/ipv4-address-space.csv"
iana <- read.csv(iana.data)
iana$Prefix <- sub("^(00|0)","",iana$Prefix, perl=TRUE)
iana$Prefix <- sub("/8$","",iana$Prefix, perl=TRUE)
rstrip <- function(x,n) {
substr(x, 1, nchar(x)-n)
}
av.IP.prefix <- rstrip(str_extract(as.character(av.df$IP),
"^([0-9]+)\\."),1)
library(stringr)
av.IP.prefix <- rstrip(str_extract(as.character(av.df$IP),
"^([0-9]+)\\."),1)
av.df$Designation <- sapply(av.IP.prefix, function(ip) {
iana[iana$Prefix == ip, ]$Designation
})
summary(av.df)
summary(av.df$Designation)
head(av.df$Designation)
table(av.df$Designation)
str(av.df)
iana.df <- data.frame(table(factor(iana$Designation)))
colnames(iana.df) <- c("Registry","IANA.Block.Count")
tmp.df <- data.frame(table(factor(av.df$Designation)))
colnames(tmp.df) <- c("Registry","AlienVault.IANA.Count")
combined.df <- merge(iana.df, tmp.df)
print(combined.df[with(combined.df, order(-IANA.Block.Count)),],
row.names=FALSE)
library(reshape)
library(grid)
library(gridExtra)
# ensure necessary packages are installed
pkg <- c("bitops","ggplot2","maps","maptools",
"sp","grid","car","reshape","gridExtra")
new.pkg <- pkg[!(pkg %in% installed.packages())]
if(length(new.pkg)) {install.packages(new.pkg)}
library(reshape)
library(grid)
library(gridExtra)
# normalize the IANA and AV values to % so bar chart scales
# match and make it easier to compare
combined.df$IANA.pct <- 100 * (combined.df$IANA.Block.Count /
sum(combined.df$IANA.Block.Count))
combined.df$AV.pct <- 100 * (combined.df$AlienVault.IANA.Count /
sum(combined.df$AlienVault.IANA.Count))
combined.df$IANA.vs.AV.pct <- combined.df$IANA.pct - combined.df$AV.pct
melted.df <- melt(combined.df)
gg1 <- ggplot(data=melted.df[melted.df$variable=="IANA.pct",],
aes(x=reorder(Registry, -value), y=value))
gg1 <- gg1 + lyim(0,40)
gg1 <- gg1 + ylim(0,40)
gg1 <- gg1 + geom_bar(stat="identity", fill=set2[3])
gg1 <- gg1 + labs(x="Registry", y="%", title="IANA %")
gg1 <- gg1 + coord_flip()
gg1 <- gg1 + theme(axis.text.x = element_text(angle=90, hjust=1),
panel.background=element_blank(),
legend.position="none")
gg2 <- ggplot(data=melted.df[melted.df$variable=="AV.pct",],
aes(x=reorder(Registry, -value), y=value))
gg2 <- gg2 + ylim(0,40)
gg2 <- gg2 + geom_bar(stat="identity", fill=set2[3])
gg2 <- gg2 + labs(x="Registry", y="%", title="AlienVault %")
gg2 <- gg2 + coord_flip()
gg2 <- gg2 + theme(axis.text.x = element_text(angle=90, hjust=1),
panel.background=element_blank(),
legend.position="none")
grid.arrange(gg1,gg2,ncol=1,nrow=2)
gg3 <- ggplot(data=combined.df,
aes(x=reorder(Registry, -IANA.Block.Count), y=AV.pct))
gg3 <- gg3 + geom_bar(stat="identity", fill=set2[4])
gg3 <- gg3 + labs(x="Registry", y="Count",
title="AV/IANA by IANA (low-to-high")
gg3 <- gg3 + coord_flip()
gg3 <- gg3 + theme(axis.text.x = element_text(angle=90, hjust=1),
panel.background=element_blank(),
legend.position="none")
gg3
gg3 <- ggplot(data=combined.df,
aes(x=reorder(Registry, -IANA.Block.Count), y=AV.pct))
gg3 <- gg3 + geom_bar(stat="identity", fill=set2[4])
gg3 <- gg3 + labs(x="Registry", y="Count",
title="AV/IANA by IANA (low-to-high)")
gg3 <- gg3 + coord_flip()
gg3 <- gg3 + theme(axis.text.x = element_text(angle=90, hjust=1),
panel.background=element_blank(),
legend.position="none")
gg3
gg <- ggplot(data=combined.df)
gg <- gg + geom_point(aes(x=IANA.Block.Count,
y=AlienVault.IANA.Count),
color=set2[1], size=4)
gg <- gg + labs(x="IANA Block Count", y="Alien Vault Count",
title="IANA ~ Alien Vault")
gg <- gg + theme(axis.text.x = element_text(angle=90,hjust=1),
panel.background = element_blank(),
legend.position = "none")
gg
cor(combined.df$IANA.Block.Count,
combined.df$AlienVault.IANA.Count, method="spearman")
hist(combined.df$IANA.Block.Count)
hist(combined.df$AlienVault.IANA.Count)
zeusURL <- "https://zeustracker.abuse.ch/blocklist.php?download=ipblocklist"
zeusData <- "data/zeus.csv"
if(file.access(zeusData)) {download.file(zeusURL,zeusData, method="curl")}
if(file.access(zeusData)) {download.file(zeusURL,zeusData)}
zeus <- read.table(zeusData,skip=5,header=FALSE,col.names=c("IP"))
# HELPER FUNCTION MENTIONED IN THE BOOK
# BUT NOT IN THE PRINTED LISTINGS
BulkOrigin <- function(ip.list,host="v4.whois.cymru.com",port=43) {
# setup query
cmd <- "begin\nverbose\n"
ips <- paste(unlist(ip.list), collapse="\n")
cmd <- sprintf("%s%s\nend\n",cmd,ips)
# setup connection and post query
con <- socketConnection(host=host,port=port,blocking=TRUE,open="r+")
cat(cmd,file=con)
response <- readLines(con)
close(con)
# trim header, split fields and convert results
response <- response[2:length(response)]
response <- laply(response,.fun=function(n) {
sapply(strsplit(n,"|",fixed=TRUE),trim)
})
response <- adply(response,c(1))
response <- subset(response, select = -c(X1) )
names(response) = c("AS","IP","BGP.Prefix","CC",
"Registry","Allocated","AS.Name")
return(response)
}
# HELPER FUNCTION MENTIONED IN THE BOOK
# BUT NOT IN THE PRINTED LISTINGS
BulkPeer <- function(ip.list,host="v4-peer.whois.cymru.com",port=43) {
# setup query
cmd <- "begin\nverbose\n"
ips <- paste(unlist(ip.list), collapse="\n")
cmd <- sprintf("%s%s\nend\n",cmd,ips)
# setup connection and post query
con <- socketConnection(host=host,port=port,blocking=TRUE,open="r+")
cat(cmd,file=con)
response <- readLines(con)
close(con)
# trim header, split fields and convert results
response <- response[2:length(response)]
response <- laply(response,function(n) {
sapply(strsplit(n,"|",fixed=TRUE),trim)
})
response <- adply(response,c(1))
response <- subset(response, select = -c(X1) )
names(response) <- c("Peer.AS","IP","BGP.Prefix","CC",
"Registry","Allocated","Peer.AS.Name")
return(response)
}
# HELPER FUNCTION MENTIONED IN THE BOOK
# BUT NOT IN THE PRINTED LISTINGS
BulkOriginASN <- function(asn.list,host="v4.whois.cymru.com",port=43) {
# setup query
cmd <- "begin\nverbose\n"
ips <- paste(unlist(asn.list), collapse="\n")
cmd <- sprintf("%s%s\nend\n",cmd,ips)
# setup connection and post query
con <- socketConnection(host=host,port=port,blocking=TRUE,open="r+")
cat(cmd,file=con)
response <- readLines(con)
close(con)
# trim header, split fields and convert results
response <- response[2:length(response)]
response <- laply(response,.fun=function(n) {
sapply(strsplit(n,"|",fixed=TRUE),trim)
})
response <- adply(response,c(1))
response <- subset(response, select = -c(X1) )
names(response) <- c("AS","CC","Registry","Allocated","AS.Name")
return(response)
}
trim <- function (x) gsub("^\\s+|\\s+$", "", x)
# HELPER FUNCTION MENTIONED IN THE BOOK
# BUT NOT IN THE PRINTED LISTINGS
BulkOrigin <- function(ip.list,host="v4.whois.cymru.com",port=43) {
# setup query
cmd <- "begin\nverbose\n"
ips <- paste(unlist(ip.list), collapse="\n")
cmd <- sprintf("%s%s\nend\n",cmd,ips)
# setup connection and post query
con <- socketConnection(host=host,port=port,blocking=TRUE,open="r+")
cat(cmd,file=con)
response <- readLines(con)
close(con)
# trim header, split fields and convert results
response <- response[2:length(response)]
response <- laply(response,.fun=function(n) {
sapply(strsplit(n,"|",fixed=TRUE),trim)
})
response <- adply(response,c(1))
response <- subset(response, select = -c(X1) )
names(response) = c("AS","IP","BGP.Prefix","CC",
"Registry","Allocated","AS.Name")
return(response)
}
# HELPER FUNCTION MENTIONED IN THE BOOK
# BUT NOT IN THE PRINTED LISTINGS
BulkPeer <- function(ip.list,host="v4-peer.whois.cymru.com",port=43) {
# setup query
cmd <- "begin\nverbose\n"
ips <- paste(unlist(ip.list), collapse="\n")
cmd <- sprintf("%s%s\nend\n",cmd,ips)
# setup connection and post query
con <- socketConnection(host=host,port=port,blocking=TRUE,open="r+")
cat(cmd,file=con)
response <- readLines(con)
close(con)
# trim header, split fields and convert results
response <- response[2:length(response)]
response <- laply(response,function(n) {
sapply(strsplit(n,"|",fixed=TRUE),trim)
})
response <- adply(response,c(1))
response <- subset(response, select = -c(X1) )
names(response) <- c("Peer.AS","IP","BGP.Prefix","CC",
"Registry","Allocated","Peer.AS.Name")
return(response)
}
# HELPER FUNCTION MENTIONED IN THE BOOK
# BUT NOT IN THE PRINTED LISTINGS
BulkOriginASN <- function(asn.list,host="v4.whois.cymru.com",port=43) {
# setup query
cmd <- "begin\nverbose\n"
ips <- paste(unlist(asn.list), collapse="\n")
cmd <- sprintf("%s%s\nend\n",cmd,ips)
# setup connection and post query
con <- socketConnection(host=host,port=port,blocking=TRUE,open="r+")
cat(cmd,file=con)
response <- readLines(con)
close(con)
# trim header, split fields and convert results
response <- response[2:length(response)]
response <- laply(response,.fun=function(n) {
sapply(strsplit(n,"|",fixed=TRUE),trim)
})
response <- adply(response,c(1))
response <- subset(response, select = -c(X1) )
names(response) <- c("AS","CC","Registry","Allocated","AS.Name")
return(response)
}
